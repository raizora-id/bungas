{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/ridho/Documents/go/github.com/red-ant-colony/web-monorepo/apps/erp/node_modules/lexical/Lexical.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\nconst DOM_DOCUMENT_TYPE = 9;\nconst DOM_DOCUMENT_FRAGMENT_TYPE = 11;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_LOWERCASE = 1 << 8;\nconst IS_UPPERCASE = 1 << 9;\nconst IS_CAPITALIZE = 1 << 10;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  capitalize: IS_CAPITALIZE,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  lowercase: IS_LOWERCASE,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n  uppercase: IS_UPPERCASE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  const isBR = dom.nodeName === 'BR';\n  const lexicalLineBreak = target.__lexicalLineBreak;\n  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== undefined;\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(getWindow(editor));\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return isDOMTextNode(targetDOM) && targetNode.isAttached();\n}\nfunction $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {\n  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {\n    const key = getNodeKeyFromDOMNode(dom, editor);\n    if (key !== undefined) {\n      const node = $getNodeByKey(key, editorState);\n      if (node) {\n        // All decorator nodes are unmanaged\n        return $isDecoratorNode(node) || !isHTMLElement(dom) ? undefined : [dom, node];\n      }\n    } else if (dom === rootElement) {\n      return [rootElement, internalGetRoot(editorState)];\n    }\n  }\n}\nfunction flushMutations(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditorSync(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);\n        if (!pair) {\n          continue;\n        }\n        const [nodeDOM, targetNode] = pair;\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {\n              if (IS_FIREFOX) {\n                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              badDOMTargets.set(nodeDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [nodeDOM, targetNode] of badDOMTargets) {\n          targetNode.reconcileObservedMutation(nodeDOM, editor);\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    flushMutations(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    flushMutations(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text', true);\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element', true);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (!isHTMLElement(activeElement)) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Text node, false otherwise.\n */\nfunction isDOMTextNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Document node, false otherwise.\n */\nfunction isDOMDocumentNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  } else if (type === 'lowercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'uppercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'capitalize') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  const key = getNodeKeyFromDOMNode(dom, editor);\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction setNodeKeyOnDOMNode(dom, editor, key) {\n  const prop = `__lexicalKey_${editor._key}`;\n  dom[prop] = key;\n}\nfunction getNodeKeyFromDOMNode(dom, editor) {\n  const prop = `__lexicalKey_${editor._key}`;\n  return dom[prop];\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markNodesWithTypesAsDirty(editor, types) {\n  // We only need to mark nodes dirty if they were in the previous state.\n  // If they aren't, then they are by definition dirty already.\n  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());\n  const dirtyNodeMaps = [];\n  for (const type of types) {\n    const nodeMap = cachedMap.get(type);\n    if (nodeMap) {\n      // By construction these are non-empty\n      dirtyNodeMaps.push(nodeMap);\n    }\n  }\n  // Nothing to mark dirty, no update necessary\n  if (dirtyNodeMaps.length === 0) {\n    return;\n  }\n  editor.update(() => {\n    for (const nodeMap of dirtyNodeMaps) {\n      for (const nodeKey of nodeMap.keys()) {\n        // We are only concerned with nodes that are still in the latest NodeMap,\n        // if they no longer exist then markDirty would raise an exception\n        const latest = $getNodeByKey(nodeKey);\n        if (latest) {\n          latest.markDirty();\n        }\n      }\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOMTree(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOMTree(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    const key = getNodeKeyFromDOMNode(node, editor);\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(getWindow(editor));\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll(selection) {\n  const root = $getRoot();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const rootNode = topParent.getParentOrThrow();\n    anchor.set(rootNode.getKey(), 0, 'element');\n    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), 'element');\n    $normalizeSelection(selection);\n    return selection;\n  } else {\n    // Create a new RangeSelection\n    const newSelection = root.select(0, root.getChildrenSize());\n    $setSelection($normalizeSelection(newSelection));\n    return newSelection;\n  }\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n/**\n * @deprecated Use {@link LexicalEditor.registerMutationListener} with `skipInitialization: false` instead.\n */\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;\n}\nfunction getDOMOwnerDocument(target) {\n  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = getDOMOwnerDocument(rootElement);\n  const defaultView = getDefaultView(doc);\n  if (doc === null || defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\n/**\n * Add a function to run after the current update. This will run after any\n * `onUpdate` function already supplied to `editor.update()`, as well as any\n * functions added with previous calls to `$onUpdate`.\n *\n * @param updateFn The function to run after the current update.\n */\nfunction $onUpdate(updateFn) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._deferred.push(updateFn);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = getDOMOwnerDocument(domElem);\n  return ownerDoc ? ownerDoc.defaultView : null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (!(registeredNode !== undefined)) {\n    throw Error(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n  }\n  const {\n    replace,\n    replaceWithKlass\n  } = registeredNode;\n  if (replace !== null) {\n    const replacementNode = replace(node);\n    const replacementNodeKlass = replacementNode.constructor;\n    if (replaceWithKlass !== null) {\n      if (!(replacementNode instanceof replaceWithKlass)) {\n        throw Error(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);\n      }\n    } else {\n      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {\n        throw Error(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);\n      }\n    }\n    if (!(replacementNode.__key !== node.__key)) {\n      throw Error(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (child !== null && needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\n/**\n * Returns the selection for the given window, or the global window if null.\n * Will return null if {@link CAN_USE_DOM} is false.\n *\n * @param targetWindow The window to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\n/**\n * Returns the selection for the defaultView of the ownerDocument of given EventTarget.\n *\n * @param eventTarget The node to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelectionFromTarget(eventTarget) {\n  const defaultView = getDefaultView(eventTarget);\n  return defaultView ? defaultView.getSelection() : null;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is a DOM Node, false otherwise.\n */\nfunction isDOMNode(x) {\n  return typeof x === 'object' && x !== null && 'nodeType' in x && typeof x.nodeType === 'number';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is a document fragment, false otherwise.\n */\nfunction isDocumentFragment(x) {\n  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * @internal\n *\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n *\n * This function returns true for a DecoratorNode that is not inline OR\n * an ElementNode that is:\n * - not a root or shadow root\n * - not inline\n * - can't be empty\n * - has no children or an inline first child\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    throw Error(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = computeTypeToNodeMap(editorState);\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * @internal\n * Compute a Map of node type to nodes for an EditorState\n */\nfunction computeTypeToNodeMap(editorState) {\n  const typeToNodeMap = new Map();\n  for (const [nodeKey, node] of editorState._nodeMap) {\n    const nodeType = node.__type;\n    let nodeMap = typeToNodeMap.get(nodeType);\n    if (!nodeMap) {\n      nodeMap = new Map();\n      typeToNodeMap.set(nodeType, nodeMap);\n    }\n    nodeMap.set(nodeKey, node);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\nfunction setNodeIndentFromDOM(elementDom, elementNode) {\n  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;\n  const indent = indentSize / 40;\n  elementNode.setIndent(indent);\n}\n\n/**\n * @internal\n *\n * Mark this node as unmanaged by lexical's mutation observer like\n * decorator nodes\n */\nfunction setDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  el.__lexicalUnmanaged = true;\n}\n\n/**\n * @internal\n *\n * True if this DOM node was marked with {@link setDOMUnmanaged}\n */\nfunction isDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  return el.__lexicalUnmanaged === true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, slot) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (slot !== null) {\n    slot.insertChild(dom);\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, element.getDOMSlot(dom));\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], slot);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  const dom = slot.element;\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(element, nodeMap) {\n  if (element) {\n    const lastKey = element.__last;\n    if (lastKey) {\n      const node = nodeMap.get(lastKey);\n      if (node) {\n        return $isLineBreakNode(node) ? 'line-break' : $isDecoratorNode(node) && node.isInline() ? 'decorator' : null;\n      }\n    }\n    return 'empty';\n  }\n  return null;\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);\n  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);\n  if (prevLineBreak !== nextLineBreak) {\n    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);\n  }\n}\nfunction reconcileTextFormat(element) {\n  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileTextStyle(element) {\n  if (subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent || '';\n  const previousDirection = dom.__lexicalDir || '';\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));\n  reconcileBlockDirection(nextElement, dom);\n  reconcileTextFormat(nextElement);\n  reconcileTextStyle(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  const dom = slot.element;\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFirstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFirstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFirstChildKey, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (!(prevChildren.length === prevChildrenSize)) {\n      throw Error(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);\n    }\n    if (!(nextChildren.length === nextChildrenSize)) {\n      throw Error(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);\n    }\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = slot.getFirstChild();\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, slot.element);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, slot.withBefore(siblingDOM));\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n        } else {\n          slot.withBefore(siblingDOM).insertChild(childDOM);\n          $reconcileNode(nextKey, slot.element);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  setNodeKeyOnDOMNode(dom, editor, key);\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet isSafariEndingComposition = false;\nlet safariEndCompositionEventData = '';\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(getWindow(editor));\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditorSync(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range  then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            if (!$isElementNode(anchorNode)) {\n              throw Error(`Point.getNode() must return ElementNode when type is element`);\n            }\n            const lastNode = anchor.getNode();\n            selection.style = '';\n            if (\n            // This previously applied to all ParagraphNode\n            lastNode.isEmpty()) {\n              selection.format = lastNode.getTextFormat();\n              selection.style = lastNode.getTextStyle();\n            } else {\n              selection.format = 0;\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(getWindow(editor));\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Triple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            const parentNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n            if ($isElementNode(parentNode)) {\n              parentNode.select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n          $setSelection(newSelection);\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (isDOMNode(target) && pointerType !== 'touch' && event.button === 0) {\n    updateEditorSync(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditorSync(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNode = selection.anchor.getNode();\n          const selectedNodeText = selectedNode.getTextContent();\n          // When the target node has `canInsertTextAfter` set to false, the first deletion\n          // doesn't have an effect, so we need to handle it with Lexical.\n          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          let shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;\n          // Check if selection is collapsed and if the previous node is a decorator node\n          // If so, the browser will not be able to handle the deletion\n          if (shouldLetBrowserHandleDelete && selection.isCollapsed()) {\n            shouldLetBrowserHandleDelete = !$isDecoratorNode($getAdjacentNode(selection.anchor, true));\n          }\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // Note that the MutationObserver may or may not have already fired,\n  // but the the DOM and selection may have already changed.\n  // See also:\n  // - https://github.com/facebook/lexical/issues/7028\n  // - https://github.com/facebook/lexical/pull/794\n\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(getWindow(editor));\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  }, {\n    event\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else if (!IS_IOS && (IS_SAFARI || IS_APPLE_WEBKIT)) {\n    // Fixhttps://github.com/facebook/lexical/pull/7061\n    // In safari, onCompositionEnd triggers before keydown\n    // This will cause an extra character to be deleted when exiting the IME\n    // Therefore, a flag is used to mark that the keydown event is triggered after onCompositionEnd\n    // Ensure that an extra character is not deleted due to the backspace event being triggered in the keydown event.\n    isSafariEndingComposition = true;\n    safariEndCompositionEventData = event.data;\n  } else {\n    updateEditorSync(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isSafariEndingComposition && isBackspace(lastKeyCode)) {\n    updateEditorSync(editor, () => {\n      $onCompositionEndImpl(editor, safariEndCompositionEventData);\n    });\n    isSafariEndingComposition = false;\n    safariEndCompositionEventData = '';\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {\n      // Only RangeSelection can use the native cut/copy/select all\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const domSelection = getDOMSelectionFromTarget(event.target);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditorSync(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n        $setSelection(newSelection);\n      }\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      throw Error(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * The base type for all serialized nodes\n */\n\n/**\n * Omit the children, type, and version properties from the given SerializedLexicalNode definition.\n */\n\n/** @internal */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    this.__parent = prevNode.__parent;\n    this.__next = prevNode.__next;\n    this.__prev = prevNode.__prev;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        const firstElement = firstPoint.getNode();\n        if (firstPoint.offset === firstElement.getChildrenSize() && firstElement.is(parentNode) && firstElement.getLastChildOrThrow().is(this)) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          throw Error(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    return {\n      type: this.__type,\n      version: 1\n    };\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  /**\n   * Update this LexicalNode instance from serialized JSON. It's recommended\n   * to implement as much logic as possible in this method instead of the\n   * static importJSON method, so that the functionality can be inherited in subclasses.\n   *\n   * The LexicalUpdateJSON utility type should be used to ignore any type, version,\n   * or children properties in the JSON so that the extended JSON from subclasses\n   * are acceptable parameters for the super call.\n   *\n   * If overridden, this method must call super.\n   *\n   * @example\n   * ```ts\n   * class MyTextNode extends TextNode {\n   *   // ...\n   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {\n   *     return $createMyTextNode()\n   *       .updateFromJSON(serializedNode);\n   *   }\n   *   updateFromJSON(\n   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,\n   *   ): this {\n   *     return super.updateFromJSON(serializedNode)\n   *       .setMyProperty(serializedNode.myProperty);\n   *   }\n   * }\n   * ```\n   **/\n  updateFromJSON(serializedNode) {\n    return this;\n  }\n\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n\n  /**\n   * @internal\n   *\n   * When the reconciler detects that a node was mutated, this method\n   * may be called to restore the node to a known good state.\n   */\n  reconcileObservedMutation(dom, editor) {\n    this.markDirty();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only childs dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return isDOMTextNode(node) && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__text = prevNode.__text;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text = '', key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTextNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!isHTMLElement(element)) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  if (!isHTMLElement(node)) {\n    return false;\n  } else if (node.nodeName === 'PRE') {\n    return true;\n  }\n  const whiteSpace = node.style.whiteSpace;\n  return typeof whiteSpace === 'string' && whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (isHTMLElement(node)) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (isDOMTextNode(node)) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  createDOM(config) {\n    const dom = super.createDOM(config);\n    const classNames = getCachedClassNameArray(config.theme, 'tab');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  static importJSON(serializedTabNode) {\n    return $createTabNode().updateFromJSON(serializedTabNode);\n  }\n  setTextContent(text) {\n    if (!(text === '\\t' || text === '')) {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n    return super.setTextContent(text);\n  }\n  setDetail(detail) {\n    if (!(detail === IS_UNMERGEABLE)) {\n      throw Error(`TabNode does not support setDetail`);\n    }\n    return this;\n  }\n  setMode(type) {\n    if (!(type === 'normal')) {\n      throw Error(`TabNode does not support setMode`);\n    }\n    return this;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    {\n      // This prevents a circular reference error when serialized as JSON,\n      // which happens on unit test failures\n      Object.defineProperty(this, '_selection', {\n        enumerable: false,\n        writable: true\n      });\n    }\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type, onlyIfChanged) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    if (onlyIfChanged && this.key === key && this.offset === offset && this.type === type) {\n      return;\n    }\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    {\n      const node = $getNodeByKey(key);\n      if (!(type === 'text' ? $isTextNode(node) : $isElementNode(node))) {\n        throw Error(`PointType.set: node with key ${key} is ${node ? node.__type : '[not found]'} and can not be used for a ${type} point`);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const overselectedFirstNode = $isElementNode(firstNode) && firstPoint.offset > 0 && firstPoint.offset >= firstNode.getChildrenSize();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n      // Prevent over-selection due to the edge case of getDescendantByIndex always returning something #6974\n      if (overselectedFirstNode) {\n        const deleteCount = nodes.findIndex(node => !node.is(firstNode) && !node.isBefore(firstNode));\n        nodes.splice(0, deleteCount);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    this.anchor.set(anchorNode.__key, anchorOffset, 'text');\n    this.focus.set(focusNode.__key, focusOffset, 'text');\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    this.anchor.set(anchorPoint.key, anchorPoint.offset, anchorPoint.type, true);\n    this.focus.set(focusPoint.key, focusPoint.offset, focusPoint.type, true);\n    // Firefox will use an element point rather than a text point in some cases,\n    // so we normalize for that\n    $normalizeSelection(this);\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Insert the provided text into the EditorState at the current Selection.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    // Now that \"removeText\" has been improved and does not depend on\n    // insertText, insertText can be greatly simplified. The next\n    // commented version is a WIP (about 5 tests fail).\n    //\n    // this.removeText();\n    // if (text === '') {\n    //   return;\n    // }\n    // const anchorNode = this.anchor.getNode();\n    // const textNode = $createTextNode(text);\n    // textNode.setFormat(this.format);\n    // textNode.setStyle(this.style);\n    // if ($isTextNode(anchorNode)) {\n    //   const parent = anchorNode.getParentOrThrow();\n    //   if (this.anchor.offset === 0) {\n    //     if (parent.isInline() && !anchorNode.__prev) {\n    //       parent.insertBefore(textNode);\n    //     } else {\n    //       anchorNode.insertBefore(textNode);\n    //     }\n    //   } else if (this.anchor.offset === anchorNode.getTextContentSize()) {\n    //     if (parent.isInline() && !anchorNode.__next) {\n    //       parent.insertAfter(textNode);\n    //     } else {\n    //       anchorNode.insertAfter(textNode);\n    //     }\n    //   } else {\n    //     const [before] = anchorNode.splitText(this.anchor.offset);\n    //     before.insertAfter(textNode);\n    //   }\n    // } else {\n    //   anchorNode.splice(this.anchor.offset, 0, [textNode]);\n    // }\n    // const nodeToSelect = textNode.isAttached() ? textNode : anchorNode;\n    // nodeToSelect.selectEnd();\n    // // When composing, we need to adjust the anchor offset so that\n    // // we correctly replace that right range.\n    // if (\n    //   textNode.isComposing() &&\n    //   this.anchor.type === 'text' &&\n    //   anchorNode.getTextContent() !== ''\n    // ) {\n    //   this.anchor.offset -= text.length;\n    // }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    if (this.isCollapsed()) {\n      return;\n    }\n    const {\n      anchor,\n      focus\n    } = this;\n    const selectedNodes = this.getNodes();\n    const firstPoint = this.isBackward() ? focus : anchor;\n    const lastPoint = this.isBackward() ? anchor : focus;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const lastBlock = $getAncestor(lastNode, INTERNAL_$isBlock);\n    // If a token is partially selected then move the selection to cover the whole selection\n    if ($isTextNode(firstNode) && firstNode.isToken() && firstPoint.offset < firstNode.getTextContentSize()) {\n      firstPoint.set(firstNode.getKey(), 0, 'text');\n    }\n    if (lastPoint.offset > 0 && $isTextNode(lastNode) && lastNode.isToken()) {\n      lastPoint.set(lastNode.getKey(), lastNode.getTextContentSize(), 'text');\n    }\n    for (const node of selectedNodes) {\n      if (!$hasAncestor(firstNode, node) && !$hasAncestor(lastNode, node) && node.getKey() !== firstNode.getKey() && node.getKey() !== lastNode.getKey()) {\n        node.remove();\n      }\n    }\n    const fixText = (node, del) => {\n      if (node.getTextContent() === '') {\n        node.remove();\n      } else if (del !== 0 && $isTokenOrSegmented(node)) {\n        const textNode = $createTextNode(node.getTextContent());\n        textNode.setFormat(node.getFormat());\n        textNode.setStyle(node.getStyle());\n        return node.replace(textNode);\n      }\n    };\n    if (firstNode === lastNode && $isTextNode(firstNode)) {\n      const del = Math.abs(focus.offset - anchor.offset);\n      firstNode.spliceText(firstPoint.offset, del, '', true);\n      fixText(firstNode, del);\n      return;\n    }\n    if ($isTextNode(firstNode)) {\n      const del = firstNode.getTextContentSize() - firstPoint.offset;\n      firstNode.spliceText(firstPoint.offset, del, '');\n      firstNode = fixText(firstNode, del) || firstNode;\n    }\n    if ($isTextNode(lastNode)) {\n      lastNode.spliceText(0, lastPoint.offset, '');\n      lastNode = fixText(lastNode, lastPoint.offset) || lastNode;\n    }\n    if (firstNode.isAttached() && $isTextNode(firstNode)) {\n      firstNode.selectEnd();\n    } else if (lastNode.isAttached() && $isTextNode(lastNode)) {\n      lastNode.selectStart();\n    }\n\n    // Merge blocks\n    const bothElem = $isElementNode(firstBlock) && $isElementNode(lastBlock);\n    if (bothElem && firstBlock !== lastBlock) {\n      firstBlock.append(...lastBlock.getChildren());\n      lastBlock.remove();\n      lastPoint.set(firstPoint.key, firstPoint.offset, firstPoint.type);\n    }\n  }\n\n  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.\n   */\n  formatText(formatType, alignWithFormat = null) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const applyFormatToElements = alignWith => {\n      selectedNodes.forEach(node => {\n        if ($isElementNode(node)) {\n          const newFormat = node.getFormatFlags(formatType, alignWith);\n          node.setTextFormat(newFormat);\n        }\n      });\n    };\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      applyFormatToElements(alignWithFormat);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);\n    applyFormatToElements(firstNextFormat);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accommodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstNode = firstPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ($isElementNode(firstBlock) && '__language' in firstBlock) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      if (!(firstBlock !== null)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);\n      }\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be a block ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(getWindow(editor));\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If the selection starts at the beginning of a text node (offset 0),\n      // extend the selection by one character in the specified direction.\n      // This ensures that the parent element is deleted along with its content.\n      // Otherwise, only the text content will be deleted, leaving an empty parent node.\n      if (this.isCollapsed() && this.anchor.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  anchor.set(focus.key, focus.offset, focus.type, true);\n  focus.set(anchorKey, anchorOffset, anchorType, true);\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.set(focus.key, characterOffset, focus.type);\n        } else {\n          anchor.set(anchor.key, characterOffset, anchor.type);\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (isHTMLElement(dom)) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        const elementDOM = editor.getElementByKey(resolvedElement.getKey());\n        if (!(elementDOM !== null)) {\n          throw Error(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);\n        }\n        const slot = resolvedElement.getDOMSlot(elementDOM);\n        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);\n        // This is just a typescript workaround, it is true but lost due to mutability\n        if (!$isElementNode(resolvedElement)) {\n          throw Error(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);\n        }\n        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {\n          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);\n        }\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          if (!$isElementNode(resolvedElement)) {\n            throw Error(`invariant`);\n          }\n          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.set(prevSibling.__key, prevSibling.getChildrenSize(), 'element');\n      } else if ($isTextNode(prevSibling)) {\n        point.set(prevSibling.__key, prevSibling.getTextContent().length, 'text');\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.set(parentSibling.__key, parentSibling.getTextContent().length, 'text');\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.set(nextSibling.__key, 0, 'element');\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.set(parentSibling.__key, 0, 'text');\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.set(anchor.key, anchor.offset, anchor.type);\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      anchor.set(lastAnchor.key, lastAnchor.offset, lastAnchor.type, true);\n      focus.set(lastFocus.key, lastFocus.offset, lastFocus.type, true);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'anchor', resolvedAnchorPoint);\n    $validatePoint(editor, 'focus', resolvedAnchorPoint);\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor, event) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(getWindow(editor));\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $validatePoint(editor, name, point) {\n  const node = $getNodeByKey(point.key);\n  if (!(node !== undefined)) {\n    throw Error(`$validatePoint: ${name} key ${point.key} not found in current editorState`);\n  }\n  if (point.type === 'text') {\n    if (!$isTextNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not a TextNode`);\n    }\n    const size = node.getTextContentSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  } else {\n    if (!$isElementNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);\n    }\n    const size = node.getChildrenSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  }\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.set(key, point.offset + (isBefore ? 0 : textLength), 'text');\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.set(point.key, point.offset - 1, 'element');\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n    // When deleting text across multiple paragraphs, Chrome on Android shifts selection rightwards\n    // This is a workaround to restore the correct selection\n    if (IS_ANDROID_CHROME) {\n      setTimeout(() => {\n        domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n      });\n    }\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    const prevNode = node;\n    [node, offset] = $splitNodeAtPoint(node, offset);\n    if (prevNode.is(node)) {\n      break;\n    }\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\nfunction addTags(editor, tags) {\n  if (!tags) {\n    return;\n  }\n  const updateTags = editor._updateTags;\n  let tags_ = tags;\n  if (!Array.isArray(tags)) {\n    tags_ = [tags];\n  }\n  for (const tag of tags_) {\n    updateTags.add(tag);\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(getWindow(editor));\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags.has('skip-dom-selection')) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n    } finally {\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          const pendingEditorState = editor._pendingEditorState;\n          if (!(pendingEditorState !== null)) {\n            throw Error(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        addTags(editor, options.tag);\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    addTags(editor, options.tag);\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  const headless = editor._headless || editor.getRootElement() === null;\n  try {\n    if (editorStateWasCloned) {\n      if (headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor, options && options.event || null);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\n/**\n * A variant of updateEditor that will not defer if it is nested in an update\n * to the same editor, much like if it was an editor.dispatchCommand issued\n * within an update\n */\nfunction updateEditorSync(editor, updateFn, options) {\n  if (!editor._updating) {\n    $beginUpdate(editor, updateFn, options);\n  } else if (activeEditor === editor) {\n    updateFn();\n  } else {\n    editor._updates.push([updateFn, options]);\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/**\n * A utility class for managing the DOM children of an ElementNode\n */\nclass ElementDOMSlot {\n  constructor(/** The element returned by createDOM */\n  element, /** All managed children will be inserted before this node, if defined */\n  before, /** All managed children will be inserted after this node, if defined */\n  after) {\n    this.element = element;\n    this.before = before || null;\n    this.after = after || null;\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted before this node\n   */\n  withBefore(before) {\n    return new ElementDOMSlot(this.element, before, this.after);\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted after this node\n   */\n  withAfter(after) {\n    return new ElementDOMSlot(this.element, this.before, after);\n  }\n  /**\n   * Return a new ElementDOMSlot with an updated root element\n   */\n  withElement(element) {\n    return new ElementDOMSlot(element, this.before, this.after);\n  }\n  /**\n   * Insert the given child before this.before and any reconciler managed line break node,\n   * or append it if this.before is not defined\n   */\n  insertChild(dom) {\n    const before = this.before || this.getManagedLineBreak();\n    if (!(before === null || before.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.insertChild: before is not in element`);\n    }\n    this.element.insertBefore(dom, before);\n    return this;\n  }\n  /**\n   * Remove the managed child from this container, will throw if it was not already there\n   */\n  removeChild(dom) {\n    if (!(dom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.removeChild: dom is not in element`);\n    }\n    this.element.removeChild(dom);\n    return this;\n  }\n  /**\n   * Replace managed child prevDom with dom. Will throw if prevDom is not a child\n   *\n   * @param dom The new node to replace prevDom\n   * @param prevDom the node that will be replaced\n   */\n  replaceChild(dom, prevDom) {\n    if (!(prevDom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.replaceChild: prevDom is not in element`);\n    }\n    this.element.replaceChild(dom, prevDom);\n    return this;\n  }\n  /**\n   * Returns the first managed child of this node,\n   * which will either be this.after.nextSibling or this.element.firstChild,\n   * and will never be this.before if it is defined.\n   */\n  getFirstChild() {\n    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;\n    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;\n  }\n  /**\n   * @internal\n   */\n  getManagedLineBreak() {\n    const element = this.element;\n    return element.__lexicalLineBreak || null;\n  }\n  /** @internal */\n  setManagedLineBreak(lineBreakType) {\n    if (lineBreakType === null) {\n      this.removeManagedLineBreak();\n    } else {\n      const webkitHack = lineBreakType === 'decorator' && (IS_IOS || IS_SAFARI);\n      this.insertManagedLineBreak(webkitHack);\n    }\n  }\n\n  /** @internal */\n  removeManagedLineBreak() {\n    const br = this.getManagedLineBreak();\n    if (br) {\n      const element = this.element;\n      const sibling = br.nodeName === 'IMG' ? br.nextSibling : null;\n      if (sibling) {\n        element.removeChild(sibling);\n      }\n      element.removeChild(br);\n      element.__lexicalLineBreak = undefined;\n    }\n  }\n  /** @internal */\n  insertManagedLineBreak(webkitHack) {\n    const prevBreak = this.getManagedLineBreak();\n    if (prevBreak) {\n      if (webkitHack === (prevBreak.nodeName === 'IMG')) {\n        return;\n      }\n      this.removeManagedLineBreak();\n    }\n    const element = this.element;\n    const before = this.before;\n    const br = document.createElement('br');\n    element.insertBefore(br, before);\n    if (webkitHack) {\n      const img = document.createElement('img');\n      img.setAttribute('data-lexical-linebreak', 'true');\n      img.style.cssText = 'display: inline !important; border: 0px !important; margin: 0px !important;';\n      img.alt = '';\n      element.insertBefore(img, br);\n      element.__lexicalLineBreak = img;\n    } else {\n      element.__lexicalLineBreak = br;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the offset of the first child\n   */\n  getFirstChildOffset() {\n    let i = 0;\n    for (let node = this.after; node !== null; node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * @internal\n   */\n  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {\n    if (initialDOM === this.element) {\n      const firstChildOffset = this.getFirstChildOffset();\n      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];\n    }\n    // The resolved offset must be before or after the children\n    const initialPath = indexPath(elementDOM, initialDOM);\n    initialPath.push(initialOffset);\n    const elementPath = indexPath(elementDOM, this.element);\n    let offset = element.getIndexWithinParent();\n    for (let i = 0; i < elementPath.length; i++) {\n      const target = initialPath[i];\n      const source = elementPath[i];\n      if (target === undefined || target < source) {\n        break;\n      } else if (target > source) {\n        offset += 1;\n        break;\n      }\n    }\n    return [element.getParentOrThrow(), offset];\n  }\n}\nfunction indexPath(root, child) {\n  const path = [];\n  let node = child;\n  for (; node !== root && node !== null; node = child.parentNode) {\n    let i = 0;\n    for (let sibling = node.previousSibling; sibling !== null; sibling = node.previousSibling) {\n      i++;\n    }\n    path.push(i);\n  }\n  if (!(node === root)) {\n    throw Error(`indexPath: root is not a parent of child`);\n  }\n  return path.reverse();\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__first = prevNode.__first;\n    this.__last = prevNode.__last;\n    this.__size = prevNode.__size;\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__textFormat;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    if (!(start + deleteCount <= oldSize)) {\n      throw Error(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);\n    }\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  /**\n   * @internal\n   *\n   * An experimental API that an ElementNode can override to control where its\n   * children are inserted into the DOM, this is useful to add a wrapping node\n   * or accessory nodes before or after the children. The root of the node returned\n   * by createDOM must still be exactly one HTMLElement.\n   */\n  getDOMSlot(element) {\n    return new ElementDOMSlot(element);\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML\n        // (see https://www.caniemail.com/features/css-padding-inline-start-end/),\n        // If you want to use HTML output for email, consider overriding the serialization\n        // to use `padding-right` in RTL languages, `padding-left` in `LTR` languages, or\n        // `text-indent` if you are ok with first-line indents.\n        // We recommend keeping multiples of 40px to maintain consistency with list-items\n        // (see https://github.com/facebook/lexical/pull/4025)\n        element.style.paddingInlineStart = `${indent * 40}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  // JSON serialization\n  exportJSON() {\n    const json = {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n    const textFormat = this.getTextFormat();\n    const textStyle = this.getTextStyle();\n    if (textFormat !== 0) {\n      json.textFormat = textFormat;\n    }\n    if (textStyle !== '') {\n      json.textStyle = textStyle;\n    }\n    return json;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || '');\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n\n  /** @internal */\n  reconcileObservedMutation(dom, editor) {\n    const slot = this.getDOMSlot(dom);\n    let currentDOM = slot.getFirstChild();\n    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {\n      const correctDOM = editor.getElementByKey(currentNode.getKey());\n      if (correctDOM === null) {\n        continue;\n      }\n      if (currentDOM == null) {\n        slot.insertChild(correctDOM);\n        currentDOM = correctDOM;\n      } else if (currentDOM !== correctDOM) {\n        slot.replaceChild(correctDOM, currentDOM);\n      }\n      currentDOM = currentDOM.nextSibling;\n    }\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    return $getRoot().updateFromJSON(serializedNode);\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createParagraphNode().updateFromJSON(serializedNode);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      // These are included explicitly for backwards compatibility\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle()\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getTextStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst DEFAULT_SKIP_INITIALIZATION = false;\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   $handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function $handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if ($isDecoratorNode(proto)) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** The version with build identifiers for this editor (since 0.17.1) */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.\n   * Listeners that run at a higher priority can \"intercept\" commands and\n   * prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners are always invoked in an {@link LexicalEditor.update} and can\n   * call dollar functions.\n   *\n   * Listeners registered at the same priority level will run\n   * deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   *   (or {@link COMMAND_PRIORITY_EDITOR} |\n   *     {@link COMMAND_PRIORITY_LOW} |\n   *     {@link COMMAND_PRIORITY_NORMAL} |\n   *     {@link COMMAND_PRIORITY_HIGH} |\n   *     {@link COMMAND_PRIORITY_CRITICAL})\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markNodesWithTypesAsDirty(this, registeredNodes.map(node => node.klass.getType()));\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload. The command listeners\n   * will be triggered in an implicit {@link LexicalEditor.update}, unless\n   * this was invoked from inside an update in which case that update context\n   * will be re-used (as if this was a dollar function itself).\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n        {\n          const nextRootElementParent = nextRootElement.parentElement;\n          if (nextRootElementParent != null && ['flex', 'inline-flex'].includes(getComputedStyle(nextRootElementParent).display)) {\n            console.warn(`When using \"display: flex\" or \"display: inline-flex\" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);\n          }\n        }\n      } else {\n        // When the content editable is unmounted we will still trigger a\n        // reconciliation so that any pending updates are flushed,\n        // to match the previous state change when\n        // `_editorState = pendingEditorState` was used, but by\n        // using a commit we preserve the readOnly invariant\n        // for editor.getEditorState().\n        this._window = null;\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    // Ensure that we have a writable EditorState so that transforms can run\n    // during a historic operation\n    let writableEditorState = editorState;\n    if (writableEditorState._readOnly) {\n      writableEditorState = cloneEditorState(editorState);\n      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = writableEditorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    // Only commit pending updates if not already in an editor.update\n    // (e.g. dispatchCommand) otherwise this will cause a second commit\n    // with an already read-only state and selection\n    if (!this._updating) {\n      $commitPendingUpdates(this);\n    }\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditorSync(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n        $addUpdateTag('focus');\n        $onUpdate(() => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        });\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.24.0+dev.esm\";\n\nexport { $addUpdateTag, $applyNodeReplacement, $cloneWithProperties, $copyNode, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createRangeSelectionFromDom, $createTabNode, $createTextNode, $getAdjacentNode, $getCharacterOffsets, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getNodeByKeyOrThrow, $getPreviousSelection, $getRoot, $getSelection, $getTextContent, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isDecoratorNode, $isElementNode, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isTabNode, $isTextNode, $isTokenOrSegmented, $nodesOfType, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $onUpdate, $parseSerializedNode, $selectAll, $setCompositionKey, $setSelection, $splitNode, ArtificialNode__DO_NOT_USE, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, INTERNAL_$isBlock, IS_ALL_FORMATTING, IS_BOLD, IS_CODE, IS_HIGHLIGHT, IS_ITALIC, IS_STRIKETHROUGH, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_UNDERLINE, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, TEXT_TYPE_TO_FORMAT, TabNode, TextNode, UNDO_COMMAND, createCommand, createEditor, getDOMOwnerDocument, getDOMSelection, getDOMSelectionFromTarget, getDOMTextNode, getEditorPropertyFromDOMNode, getNearestEditorFromDOMNode, isBlockDomNode, isCurrentlyReadOnlyMode, isDOMDocumentNode, isDOMNode, isDOMTextNode, isDOMUnmanaged, isDocumentFragment, isHTMLAnchorElement, isHTMLElement, isInlineDomNode, isLexicalEditor, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor, resetRandomKey, setDOMUnmanaged, setNodeIndentFromDOM };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10460, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}